(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{498:function(e,o,s){"use strict";s.r(o);var t=s(4),r=Object(t.a)({},(function(){var e=this,o=e.$createElement,s=e._self._c||o;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[s("img",{attrs:{src:"https://pic4.zhimg.com/v2-787d9eac1a214f5b179659cf1f065aae_1440w.jpg?source=172ae18b",alt:"从node开发谈谈单点登录及鉴权的坑"}})]),e._v(" "),s("h1",{attrs:{id:"从node开发谈谈单点登录及鉴权的坑"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从node开发谈谈单点登录及鉴权的坑"}},[e._v("#")]),e._v(" 从node开发谈谈单点登录及鉴权的坑")]),e._v(" "),s("p",[e._v("“单点登录”、“鉴权” 建议自行查阅，我们来聊聊接入单点登录及鉴权时遇到的问题及解决方案：")]),e._v(" "),s("p",[e._v("公司内部采用cookie来实现单点登录，java层面单点登录相关方提供了相关SDK（ps：吐槽一下，你以为前端这边很少有人知道单点登录实现的方案及原理，殊不知一大批服务端也不知道），我们的系统采用node作为中间层转发，但是我司并没有提供Node相关SSO包，所以我们得自己撸一套，此处阐述一下原理：")]),e._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("Client端携带cookie")]),e._v("  "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v("  server解析Cookie并访问sso"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("system")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" 返回单点登录信息 \n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("我们可以看到cookie是重头戏，关于cookie我们不再赘述，请于MDN自行查阅，列举几个遇到的坑：")]),e._v(" "),s("ol",[s("li",[e._v("前端无法访问cookie\n出于安全考虑，HttpOnly属性都被设置成true，前端无法访问cookie，我们的系统功能中台采用服务端渲染，于是我们通过node层来访问cookie，此处有个巨坑，不同于服务端sso的SDK自动注入cookie，node这边需要自行注入，通过首次访问单点登录页面后的querystring来解析注入")]),e._v(" "),s("li",[e._v("nuxt-server访问不到cookie\n既然前端访问不到cookie，那么服务端应该可以了吧，于是我们通过nuxt的server层来访问cookie，写了那么多篇cookie分析的小伙伴，这个知识点终于派上用场了，cookie有自己的作用域，Domain 指定了哪些主机可以接受 Cookie。如果不指定，默认为 origin，不包含子域名。如果指定了Domain，则一般包含子域名。例如，如果设置 "),s("code",[e._v("Domain=mozilla.org")]),e._v("，则 Cookie 也包含在子域名中（如"),s("code",[e._v("developer.mozilla.org")]),e._v("），所以本地开发时需配置host，将域名的domain配置为对应的单点登录系统domain，此时即可访问到cookie")]),e._v(" "),s("li",[e._v("服务端渲染如何透传cookie\n我们在nuxt的server层访问到了cookie，于是我们访问系统的node中间层获取单点登录信息，但是我们发现无法如何在node端都获取不到cookie，之后我们通过打印请求头才发现，cookie根本没有携带过来，也就是说，当我们的nuxt的server层访问node时，cookie不翼而飞了，这是由于跨域（前后端分离项目大概率会出现跨域情况）请求时ajax默认不会携带cookie，如果想要携带cookie，需要设置 ‘withCredentials: true’，现在你明白为什么你的项目中axios都设置了这个属性了吧")]),e._v(" "),s("li",[e._v("设置了withCredentials还是显示跨域")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://pic1.zhimg.com/80/v2-69a39086afd7cb06570661dbcdf2b2d4_1440w.png",alt:"img"}})]),e._v(" "),s("p",[e._v("这个现象是不是很熟悉，开发的时候是不是经常遇到，如果下次再遇到这个问题，服务端也解决不了，那么就是你展示的时候了！\n这个现象是由于ajax设置了"),s("code",[e._v("withCredentials")]),e._v("属性之后，服务端没有做对应的跨域处理，或者做了跨域处理，但是origin设置为了‘*’，当配置了"),s("code",[e._v("withCredentials = true")]),e._v("时，必须在后端增加 "),s("code",[e._v("response")]),e._v(" 头信息"),s("code",[e._v("Access-Control-Allow-Origin")]),e._v("，且必须指定域名，于是我们修改成对应域名后跨域问题解决，如下：\n"),s("code",[e._v("response.set('Access-Control-Allow-Origin', '此处填写域名')")]),e._v(";\n"),s("code",[e._v("response.set('Access-Control-Allow-Credentials', true)")]),e._v(";\n当然如果你采用egg或者koa，有对应的插件例如"),s("code",[e._v("egg-cors")]),e._v("或者"),s("code",[e._v("koa/cors")]),e._v("来配置解决，实质上前者就是对后者做了一层封装")]),e._v(" "),s("ol",[s("li",[e._v("多个域名如何解决呢\n如果是开发环境，有一个一劳永逸的方法'Access-Control-Allow-Origin'设置为request.header.origin，但是线上环境千万别这么干，可以配置为一个数组，需要哪些域名就按需增加即可")]),e._v(" "),s("li",[e._v("接口鉴权\n单点登录之后的一系列接口接入权限系统，才能实现鉴权，鉴权的时候需要透传token、工号及IP，当我们经过一系列的骚操作之后，此时的IP还是之前的client IP吗，显然不是，从请求头解析的IP一定是最后一次请求方，这里是我们的server层，那如何透传IP呢，想象一下如下场景，这个IP到底怎么查？\n客户端 => 正向代理 => 透明代理 => 服务器反向代理 => Web服务器 =>...\n最后我们借助’ X-Forward-For‘（这个自己查阅吧，篇幅不够了）来实现，此处省略大量篇幅")]),e._v(" "),s("li",[e._v("Provisional headers are shown\n另外，如果你在调试的时候遇到下面这个现象，")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://pic3.zhimg.com/80/v2-9b1cdbc68b88a1186ebc45a36b48e22a_1440w.jpg",alt:"img"}})]),e._v(" "),s("p",[e._v("记得这个是options（预检）请求，这是浏览器自己发的，是不是能明白为什么除了get、post等你从来没有见过options请求了，这块知识感兴趣的话自行了解，主要堵塞的原因可能有以下几种，请自行解决：")]),e._v(" "),s("p",[e._v("a.跨域请求被浏览器拦截")]),e._v(" "),s("p",[e._v("b.服务器未及时响应（超时）")]),e._v(" "),s("p",[e._v("c.请求被浏览器插件拦截")]),e._v(" "),s("p",[e._v("d.该数据直接采用了缓存，并没有发送请求")]),e._v(" "),s("p",[e._v("未来会给大家带来更多node开发相关知识分享，敬请期待")])])}),[],!1,null,null,null);o.default=r.exports}}]);